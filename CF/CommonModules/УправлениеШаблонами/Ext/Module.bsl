#Область ПрограммныйИнтерфейс

#Область ШаблоныДляФискальныхРегистраторовИПринтеровЧеков

// Функция вставляет в текстовый макет параметры области.
//
// Параметры:
//  ШаблонЧека  - ДеревоЗначений - Дерево значений шаблона.
//
Функция ВыполнитьКомпоновкуДанныхДляИерархическогоШаблона(ШаблонЧека, Ссылка, СхемаКомпоновкиДанных, Компоновщик, ИдентификаторыПолейСКД = Неопределено, ИмяМакета = "") Экспорт

	РезультатЗапроса = Новый ДеревоЗначений;
	
	Если СхемаКомпоновкиДанных = Неопределено ИЛИ Компоновщик = Неопределено Тогда
		СхемаКомпоновкиДанных = ПолучитьСхемуСКДДляПодстановкиВШаблоне(Ссылка.Метаданные(), ИмяМакета);
	КонецЕсли;
		
	Если  Компоновщик = Неопределено Тогда
		// Подготовка компоновщика макета компоновки данных.
		Компоновщик = Новый КомпоновщикНастроекКомпоновкиДанных;
		Компоновщик.Инициализировать(Новый ИсточникДоступныхНастроекКомпоновкиДанных(СхемаКомпоновкиДанных));
	КонецЕсли;
	
	Компоновщик.ЗагрузитьНастройки(СхемаКомпоновкиДанных.НастройкиПоУмолчанию);
	
	// Переносим настройки выбранных полей из настроек шаблона.
	Кэш = Новый Соответствие;
	ИдентификаторыПолейСКД = ПолучитьИдентификаторыПолейСКД(ШаблонЧека);
	Для каждого ЭлементСтруктуры Из ИдентификаторыПолейСКД Цикл
		ДобавитьВыбранноеПолеСКД(Компоновщик, ЭлементСтруктуры.Значение, ЭлементСтруктуры.Ключ, Кэш);
	КонецЦикла;
	
	// Отбор по ссылке
	ПолеОтбора = КомпоновкаДанныхСервер.НайтиПолеСКДПоПолномуИмени(Компоновщик.Настройки.Отбор.ДоступныеПоляОтбора.Элементы, "Ссылка");
	Если ПолеОтбора <> Неопределено Тогда
		ДобавитьОтборВНастройкиСКД(Компоновщик.Настройки,ПолеОтбора.Поле, Ссылка, ВидСравненияКомпоновкиДанных.Равно);
	КонецЕсли;
	
	// Компоновка макета СКД
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	МакетСКД = КомпоновщикМакета.Выполнить(СхемаКомпоновкиДанных, Компоновщик.Настройки,,,Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений"));
	
	Процессор = Новый ПроцессорКомпоновкиДанных;
	Процессор.Инициализировать(МакетСКД);
	
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
	ПроцессорВывода.УстановитьОбъект(РезультатЗапроса);
	ПроцессорВывода.Вывести(Процессор);

	// Подготовка итоговых строк
	Для каждого СтрокаДерева Из РезультатЗапроса.Строки Цикл
	
		Для каждого ВыбранноеПоле Из Компоновщик.Настройки.Выбор.Элементы Цикл
			
			ПолеСКД = КомпоновкаДанныхСервер.НайтиПолеСКДПоПолномуИмени(Компоновщик.Настройки.Выбор.ДоступныеПоляВыбора.Элементы, ВыбранноеПоле.Поле, Кэш);
			Если ПолеСКД <> Неопределено Тогда
				Если НЕ ПолеСКД.Ресурс Тогда
					
					Если СтрокаДерева.Строки.Количество() > 0 Тогда
						Колонка = РезультатЗапроса.Колонки.Найти(СтрЗаменить(ВыбранноеПоле.Поле,".",""));
						Значение = СтрокаДерева.Строки[0].Получить(РезультатЗапроса.Колонки.Индекс(Колонка));
						СтрокаДерева.Установить(РезультатЗапроса.Колонки.Индекс(Колонка),Значение);
					КонецЕсли;
					
				КонецЕсли;
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат РезультатЗапроса;
	
КонецФункции

// Функция генерирует уникальный идентификатор строки дерева шаблона.
//
// Параметры:
//  Нет
//
// Возвращаемое значение:
//   <Строка>   - Уникальный идентификатор
//
Функция ПолучитьИдентификатор() Экспорт
	
	Возврат "ID"+СтрЗаменить(Новый УникальныйИдентификатор,"-","_");
	
КонецФункции

// Процедура производит заполнение структуры параметров по строке табличной части.
//
// Параметры:
//  СтрокаТаблицыЗначений      - <СтрокаТаблицыЗначений> - Строка таблицы значений.
//  ШаблонЧека  - <КоллекцияСтрокДереваЗначений> - Коллекция строк дерева значений.
//  Структура  - <Структура> - Структура параметров
//
Процедура ЗаполнитьСтруктуруПараметровШаблонаПоСтрокеТЧ(СтрокаТаблицыЗначений, Структура, ШаблонЧека) Экспорт
	
	Индекс = 0;
	ТаблицаЗначений = СтрокаТаблицыЗначений.Владелец();
	Для каждого ЗначениеКолонки Из СтрокаТаблицыЗначений Цикл
		
		ИмяКолонки = ТаблицаЗначений.Колонки[Индекс];
		
		Отбор = Новый Структура;
		Отбор.Вставить("ИмяКолонки",ИмяКолонки.Имя);
		МассивСтрок = ШаблонЧека.Строки.НайтиСтроки(Отбор,Истина);
		Для каждого СтрокаМассива Из МассивСтрок Цикл
			
			// Префикс и постфикс
			Префикс  = СтрокаМассива.Префикс;
			ПостФикс = СтрокаМассива.Постфикс;
			
			// Обработаем Null
			Если ЗначениеКолонки = NULL Тогда
				Значение = ?(СтрокаМассива.СтрокаПустоеЗначение = "","",Префикс) + СтрокаМассива.СтрокаПустоеЗначение + ?(СтрокаМассива.СтрокаПустоеЗначение = "","",ПостФикс);
				Значение = СтрЗаменить(Значение,"¶",Символы.ПС);
				Структура.Вставить(СтрокаМассива.Идентификатор,Значение);
			Иначе
				
				ЗначениеКолонкиЗаполнено = Ложь;
				Если СтрокаМассива.ПустоеЗначение = Неопределено Тогда
					// Необходимо проводить стандартную проверку заполненности значения.
					Если ЗначениеЗаполнено(ЗначениеКолонки) Тогда
						 ЗначениеКолонкиЗаполнено = Истина;
					КонецЕсли;
				Иначе
					// Заполненность определяется по неравенству значению ПустоеЗначение.
					Если СтрокаМассива.ПустоеЗначение <> ЗначениеКолонки Тогда
						 ЗначениеКолонкиЗаполнено = Истина;
					КонецЕсли;
				КонецЕсли;
				
				Если ЗначениеКолонкиЗаполнено Тогда
					Значение = Формат(ЗначениеКолонки,СтрокаМассива.Формат);
					Значение = СтрЗаменить(Префикс+Значение+ПостФикс,"¶",Символы.ПС);
					Структура.Вставить(СтрокаМассива.Идентификатор,Значение);
				Иначе
					Значение = ?(СтрокаМассива.СтрокаПустоеЗначение = "","",Префикс) + СтрокаМассива.СтрокаПустоеЗначение + ?(СтрокаМассива.СтрокаПустоеЗначение = "","",ПостФикс);
					Значение = СтрЗаменить(Значение,"¶",Символы.ПС);
					Структура.Вставить(СтрокаМассива.Идентификатор,Значение);
				КонецЕсли;
				
			КонецЕсли;
		
		КонецЦикла;
		
		// Для обхода ошибки, возникающей если свойство имеет сложное имя.
		Попытка
			Структура.Вставить(ИмяКолонки.Имя, ?(ЗначениеКолонки = NULL, "", ЗначениеКолонки));
		Исключение
		КонецПопытки;
		
		Индекс = Индекс + 1;
		
	КонецЦикла;
	
КонецПроцедуры

// Функция заполняет структуру параметров значениями составных строк.
// Рекурсивная функция.
//
// Параметры:
//  Шаблон  - <ДеревоЗначений> - Шаблон. В строках шаблона могут находиться параметры.
//  Структура  - <Структура> - Структура, которую необходимо заполнить значениями составных строк.
//
// Возвращаемое значение:
//   Структура   - структура параметров.
//
Процедура ЗаполнитьСоставныеСтрокиПоСтруктуре(ШаблонЧека, Структура) Экспорт
	
	// Заполняем значения составных полей.
	Отбор = Новый Структура;
	Отбор.Вставить("ТипЭлемента","СоставнаяСтрока");
	Массив = ШаблонЧека.Строки.НайтиСтроки(Отбор,Истина);
	
	ТЗ = Новый ТаблицаЗначений;
	ТЗ.Колонки.Добавить("СоставнаяСтрока");
	ТЗ.Колонки.Добавить("Уровень");
	
	// Выбираем составные строки...
	Для каждого СоставнаяСтрока Из Массив Цикл
		НоваяСтрока = ТЗ.Добавить();
		НоваяСтрока.СоставнаяСтрока = СоставнаяСтрока;
		НоваяСтрока.Уровень = СоставнаяСтрока.Уровень();
	КонецЦикла;
	
	ТЗ.Сортировать("Уровень Убыв");
	
	// Выбираем составные строки в порядке возрастания уровней.
	Для каждого СтрокаТЗ Из ТЗ Цикл
		
		ЗначениеСоставнойСтроки = "";
		
		// Склеиваем значение составной строки из значений входящих в нее полей.
		Для каждого Строка Из СтрокаТЗ.СоставнаяСтрока.Строки Цикл
			
			Если Строка.ТипЭлемента = "СтрокаТекста" И Строка.Вычислять Тогда
				Попытка
					Значение = Вычислить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Строка.Элемент,".",""),"%",""),"Структура","Структура."));
				Исключение
					Значение = НСтр("ru = 'Ошибка вычисления!'");
				КонецПопытки;
			Иначе
				Структура.Свойство(Строка.Идентификатор, Значение);
				Если Значение = Неопределено Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			
			// Форматируем, если задан формат строки.
			Если Строка.Формат <> "" И ТипЗнч(Значение) <> Тип("Строка") Тогда
				Значение = Формат(Значение,Строка.Формат);
			КонецЕсли;
			
			ЗначениеСоставнойСтроки = ЗначениеСоставнойСтроки + Значение;
			
		КонецЦикла;
		
		// Проверка на заполненность
		ЗначениеКолонкиЗаполнено = Ложь;
		Если СтрокаТЗ.СоставнаяСтрока.ПустоеЗначение = Неопределено Тогда
			// Необходимо проводить стандартную проверку заполненности значения.
			Если ЗначениеЗаполнено(ЗначениеСоставнойСтроки) Тогда
				ЗначениеКолонкиЗаполнено = Истина;
			КонецЕсли;
		Иначе
			// Заполненность определяется по неравенству значению ПустоеЗначение.
			Если СтрокаТЗ.СоставнаяСтрока.ПустоеЗначение <> ЗначениеСоставнойСтроки Тогда
				ЗначениеКолонкиЗаполнено = Истина;
			КонецЕсли;
		КонецЕсли;
		
		Если ЗначениеКолонкиЗаполнено Тогда
			ЗначениеСоставнойСтроки = СтрЗаменить(ЗначениеСоставнойСтроки,"¶",Символы.ПС);
			Структура.Вставить(СтрокаТЗ.СоставнаяСтрока.Идентификатор, ЗначениеСоставнойСтроки);
		Иначе
			ЗначениеСоставнойСтроки = СтрЗаменить(СтрокаТЗ.СоставнаяСтрока.СтрокаПустоеЗначение,"¶",Символы.ПС);
			Структура.Вставить(СтрокаТЗ.СоставнаяСтрока.Идентификатор, ЗначениеСоставнойСтроки);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Функция заполняет структуру параметров, которые заданы пользователем
// или являются составными строками.
// Рекурсивная функция.
//
// Параметры:
//  Шаблон  - <ДеревоЗначений> - Шаблон. В строках шаблона могут находиться параметры.
//  Структура  - <Структура> - Структура, которую необходимо заполнить параметрами.
//
// Возвращаемое значение:
//   Структура   - структура параметров, которые заданы пользователем.
//
Функция ПолучитьИдентификаторыПользовательскихПолей(Шаблон, Структура = Неопределено) Экспорт

	Если Структура = Неопределено Тогда
		Структура = Новый Структура;
	КонецЕсли;
	
	Для каждого Строка Из Шаблон.Строки Цикл
		
		ТипЭлемента = Строка.ТипЭлемента;
		
		Если ТипЭлемента = "Таблица"
			ИЛИ ТипЭлемента = "СоставнаяСтрока"
			ИЛИ ТипЭлемента = "ОбластьЧека" Тогда
			ПолучитьИдентификаторыПользовательскихПолей(Строка, Структура);
		КонецЕсли;
		
		Если ТипЭлемента = "СоставнаяСтрока" 
			ИЛИ ТипЭлемента = "СтрокаТекста" Тогда
			
			// Префикс и постфикс
			Префикс  = Строка.Префикс;
			Значение = Строка.Элемент;
			ПостФикс = Строка.Постфикс;
			
			// Проверка на заполненность
			ЗначениеКолонкиЗаполнено = Ложь;
			Если Строка.ПустоеЗначение = Неопределено Тогда
				// Необходимо проводить стандартную проверку заполненности значения.
				Если ЗначениеЗаполнено(Значение) Тогда
					ЗначениеКолонкиЗаполнено = Истина;
				КонецЕсли;
			Иначе
				// Заполненность определяется по неравенству значению ПустоеЗначение.
				Если Строка.ПустоеЗначение <> Значение Тогда
					ЗначениеКолонкиЗаполнено = Истина;
				КонецЕсли;
			КонецЕсли;

			Если ЗначениеКолонкиЗаполнено Тогда
				Значение = Префикс+Значение+ПостФикс;
				Значение = СтрЗаменить(Значение,"¶",Символы.ПС);
				Структура.Вставить(Строка.Идентификатор,Префикс+Значение+ПостФикс);
			Иначе
				Значение = ?(Строка.СтрокаПустоеЗначение = "","",Префикс) + Строка.СтрокаПустоеЗначение + ?(Строка.СтрокаПустоеЗначение = "","",ПостФикс);
				Значение = СтрЗаменить(Значение,"¶",Символы.ПС);
				Структура.Вставить(Строка.Идентификатор, Значение);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;

	Возврат Структура;
	
КонецФункции

// Функция выполняет преобразование шаблона (строки дерева) в массив текстовых строк, заполненный по структуре
// параметров.
//
// Параметры:
//  <СтрокаДерева>  - <СтрокаДереваЗначений> - строка шаблона
//  <СтруктураПараметров>  - <Структура> - параметры, которые необходимо 
//                 подставить в макет шаблона.
//
// Возвращаемое значение:
//   <Массив>   - результирующий массив текстовых строк,
//   полученный по макету для строки дерева.
//
Функция ПолучитьМассивСтрокДляСтрокиДереваШаблона(СтрокаДерева, СтруктураПараметров) Экспорт
	
	ТекстовыйДокумент = ПолучитьТекстовыйДокументДляСтрокиДереваШаблона(СтрокаДерева, СтруктураПараметров);
	Возврат ПреобразоватьТекстовыйДокументВМассивСтрок(ТекстовыйДокумент);
	
КонецФункции

#КонецОбласти

#Область ШаблоныДляККТ

Функция ТаблицаСКД(СКД, ДокументСсылка) Экспорт
	
	Настройки = СКД.НастройкиПоУмолчанию;
	ПараметрЧек = Настройки.ПараметрыДанных.НайтиЗначениеПараметра(Новый ПараметрКомпоновкиДанных("ДокументСсылка"));
	Если ПараметрЧек <> Неопределено Тогда
		ПараметрЧек.Значение = ДокументСсылка;
		ПараметрЧек.Использование = Истина;
	КонецЕсли;
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	МакетКомпоновки = КомпоновщикМакета.Выполнить(
		СКД,
		Настройки,
		,
		,
		Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений"));
	ПроцессорКомпоновкиДанных = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновкиДанных.Инициализировать(МакетКомпоновки);
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
	ТаблицаЗначений = Новый ТаблицаЗначений;
	ПроцессорВывода.УстановитьОбъект(ТаблицаЗначений);
	ПроцессорВывода.Вывести(ПроцессорКомпоновкиДанных);
	
	Возврат ТаблицаЗначений;

КонецФункции

Функция ЗначениеТекстовогоПоля(ДокументСсылка, ПоляСтроки, СтрокаШапкиЧека, ТаблицаДанных, СтрокаДанных = Неопределено, ИмяРаздела = "СоставЧека") Экспорт
	
	ЗначениеСтроки = Неопределено;
	
	Если ПоляСтроки.Элемент = "%%Скидки.СуммаНакопления%%" Тогда
		РеквизитыДокумента = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(ДокументСсылка, "Ссылка, Дата, Проведен, ВидОперации, ДисконтнаяКарта, СтатусЧекаККМ, ОтчетОРозничныхПродажах");
		Если ЗначениеЗаполнено(РеквизитыДокумента.ДисконтнаяКарта) Тогда
			Если РеквизитыДокумента.Дата = НачалоДня(ТекущаяДатаСеанса()) Тогда
				РеквизитыДокумента.Дата = ТекущаяДатаСеанса();
			КонецЕсли;
			ЗначениеСтроки = СкидкиНаценкиСерверПереопределяемый.СуммаНакопленияПоКартеДляПечатиЧека(РеквизитыДокумента);
		КонецЕсли;
	ИначеЕсли ПоляСтроки.Элемент = "%%Скидки.НакопленоБаллов%%" Тогда
		РеквизитыДокумента = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(ДокументСсылка, "Ссылка, Дата, Проведен, ВидОперации, ДисконтнаяКарта, СтатусЧекаККМ, ОтчетОРозничныхПродажах");
		Если ЗначениеЗаполнено(РеквизитыДокумента.ДисконтнаяКарта) Тогда
			Если РеквизитыДокумента.Дата = НачалоДня(ТекущаяДатаСеанса()) Тогда
				РеквизитыДокумента.Дата = ТекущаяДатаСеанса();
			КонецЕсли;
			БонуснаяПрограмма = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(
									РеквизитыДокумента.ДисконтнаяКарта,
									"БонуснаяПрограммаЛояльности");
			Если ЗначениеЗаполнено(БонуснаяПрограмма) Тогда
				Если РеквизитыДокумента.Дата = НачалоДня(ТекущаяДатаСеанса()) Тогда
					РеквизитыДокумента.Дата = ТекущаяДатаСеанса();
				КонецЕсли;
				ЗначениеСтроки = БонусныеБаллыСервер.КоличествоНакопленныхБалловДляПечатиЧека(РеквизитыДокумента);
			КонецЕсли;
		КонецЕсли;
	Иначе
		ЗначениеСтроки = Неопределено;
		Если ПоляСтроки.Вычислять Тогда
			Попытка
				Если СтрокаДанных = Неопределено Тогда
					ЗначениеСтроки = СтрокаШапкиЧека[ПоляСтроки.Элемент];
				Иначе
					ЕстьКолонка = Ложь;
					Если ТаблицаДанных.Колонки.Найти(ПоляСтроки.Элемент) = Неопределено Тогда
						Если СтрокаДанных <> Неопределено Тогда
							Попытка
								Если СтрокаДанных.Свойство(ПоляСтроки.Элемент) Тогда
									Если СтрокаДанных[ПоляСтроки.Элемент] <> Null Тогда
										// Если null - то значение или в шапке, или в другом разделе.
										ЕстьКолонка = Истина;
									КонецЕсли;
								КонецЕсли;
							Исключение
								ТекстОшибки = ОписаниеОшибки();
							КонецПопытки;
						КонецЕсли;
					Иначе
						Если СтрокаДанных[ПоляСтроки.Элемент] <> Null Тогда
							// Если null - то значение или в шапке, или в другом разделе.
							ЕстьКолонка = Истина;
						КонецЕсли;
					КонецЕсли;
					Если ЕстьКолонка Тогда
						ЗначениеСтроки = СтрокаДанных[ПоляСтроки.Элемент];
					Иначе
						// Пытаемся найти в шапке.
						ЗначениеСтроки = СтрокаШапкиЧека[ПоляСтроки.Элемент];
					КонецЕсли;
				КонецЕсли;
			Исключение
				ТекстОшибки = ОписаниеОшибки();
			КонецПопытки;
		Иначе
			ЗначениеСтроки = ПоляСтроки.Элемент;
		КонецЕсли;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ЗначениеСтроки) Тогда
		Если ПоляСтроки.ВыводитьПустоеЗначение Тогда
			ЗначениеСтроки = ПоляСтроки.ПустоеЗначение;
		КонецЕсли;
	КонецЕсли;
	
	Возврат ЗначениеСтроки;
	
КонецФункции

Процедура ОбработатьСоставЧека(ПараметрыЧека, СтрокаОсновногоРаздела, ТаблицаДанных, ФискальныеПозицииЧека = Неопределено) Экспорт
	
	СтрокаШапкиЧека = Неопределено;
	СтруктураОтбора = Новый Структура;
	СтруктураОтбора.Вставить("ИмяТаблицы", "СоставЧека");
	СтрокиВыборки = ТаблицаДанных.НайтиСтроки(СтруктураОтбора);
	Для Каждого СтрокаВыборки Из СтрокиВыборки Цикл
		СтрокаШапкиЧека = СтрокаВыборки;
		Прервать;
	КонецЦикла;
	
	Если СтрокаОсновногоРаздела.ИмяКолонки = "Текст" Тогда
		Если СтрокаОсновногоРаздела.ВыводитьКакШтрихкод Тогда
			ОбработатьДанныеШтрихкода(ПараметрыЧека, СтрокаОсновногоРаздела, СтрокаШапкиЧека, ТаблицаДанных);
		Иначе
			ОбработатьТекстовуюСтроку(ПараметрыЧека, СтрокаОсновногоРаздела, СтрокаШапкиЧека, ТаблицаДанных);
		КонецЕсли;
	ИначеЕсли СтрокаОсновногоРаздела.ИмяКолонки = "СоставнаяСтрока" Тогда
		ОбработатьСоставнуюСтроку(ПараметрыЧека, СтрокаОсновногоРаздела, СтрокаШапкиЧека, ТаблицаДанных);
	ИначеЕсли СтрокаОсновногоРаздела.ИмяКолонки = "Таблица" Тогда
		СтруктураОтбора = Новый Структура;
		ИмяТаблицы = СтрокаОсновногоРаздела.Элемент;
		СтруктураОтбора.Вставить("ИмяТаблицы", ИмяТаблицы);
		СтрокиВыборки = ТаблицаДанных.НайтиСтроки(СтруктураОтбора);
		Для Каждого СтрокаВыборки Из СтрокиВыборки Цикл
			Для Каждого ПоляСтрокиТаблицы Из СтрокаОсновногоРаздела.Строки Цикл
				Если ПоляСтрокиТаблицы.ИмяКолонки = "СоставнаяСтрока" Тогда
					ОбработатьСоставнуюСтроку(ПараметрыЧека, ПоляСтрокиТаблицы, СтрокаШапкиЧека, ТаблицаДанных, СтрокаВыборки, ИмяТаблицы);
					
				ИначеЕсли ПоляСтрокиТаблицы.ИмяКолонки = "Текст" Тогда
					Если ПоляСтрокиТаблицы.ВыводитьКакШтрихкод Тогда
						ОбработатьДанныеШтрихкода(ПараметрыЧека, ПоляСтрокиТаблицы, СтрокаШапкиЧека, ТаблицаДанных, СтрокаВыборки, ИмяТаблицы);
					Иначе
						ОбработатьТекстовуюСтроку(ПараметрыЧека, ПоляСтрокиТаблицы, СтрокаШапкиЧека, ТаблицаДанных, СтрокаВыборки, ИмяТаблицы);
					КонецЕсли;
					
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
		
	ИначеЕсли СтрокаОсновногоРаздела.ИмяКолонки = "ТаблицаТовары" Тогда
		Если ФискальныеПозицииЧека = Неопределено Тогда
			СтрокаИсключения = НСтр("ru = 'Некорректно настроен шаблон чека. Отсутствует фискальный раздел в таблице товаров.'");
			ВызватьИсключение СтрокаИсключения;
		КонецЕсли;
		ПоследняяСтрока = 0;
		ИндексПоследнейПозиции = ФискальныеПозицииЧека.ВГраница();
		ИндексТекущейПозиции = 0;
		Пока ИндексТекущейПозиции <= ИндексПоследнейПозиции Цикл
			СтрокаВыборки = ФискальныеПозицииЧека[ИндексТекущейПозиции];
			ФискальныйРазделБыл = Ложь;
			ВыводитьНефискальныеПосле = Истина;
			Для Каждого ПоляСтрокиТаблицы Из СтрокаОсновногоРаздела.Строки Цикл
				Если ПоляСтрокиТаблицы.ИмяКолонки = "ФискальныйРаздел" Тогда
					ФискальныйРазделБыл = Истина;
					
					СтрокаПозицииЧека = Новый Структура;
					Для Каждого ЭлементЧека Из СтрокаВыборки Цикл
						СтрокаПозицииЧека.Вставить(ЭлементЧека.Ключ, ЭлементЧека.Значение);
					КонецЦикла;
					ПараметрыЧека.ПозицииЧека.Добавить(СтрокаПозицииЧека);
					
					Если ИндексТекущейПозиции < ИндексПоследнейПозиции Тогда
						СледущаяСтрока = ФискальныеПозицииЧека[ИндексТекущейПозиции + 1];
						Если СледущаяСтрока.НомерСтрокиТовара = СтрокаВыборки.НомерСтрокиТовара Тогда
							ВыводитьНефискальныеПосле = Ложь;
						КонецЕсли;
					КонецЕсли;
				ИначеЕсли ПоляСтрокиТаблицы.ИмяКолонки = "СоставнаяСтрока" Тогда
					Если ФискальныйРазделБыл Тогда
						Если НЕ ВыводитьНефискальныеПосле Тогда
							Продолжить;
						КонецЕсли;
					Иначе
						Если ИндексТекущейПозиции > 0 Тогда
							ПредыдущаяСтрока = ФискальныеПозицииЧека[ИндексТекущейПозиции - 1];
							Если ПредыдущаяСтрока.НомерСтрокиТовара = СтрокаВыборки.НомерСтрокиТовара Тогда
								Продолжить;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
					
					СтруктураПоиска = Новый Структура;
					СтруктураПоиска.Вставить("НомерСтрокиТовара", СтрокаВыборки.НомерСтрокиТовара);
					СтруктураПоиска.Вставить("ИмяТаблицы", "Товары");
					СтрокиДанных = ТаблицаДанных.НайтиСтроки(СтруктураПоиска);
					Если СтрокиДанных.Количество() > 0 Тогда
						СтрокаДанных = СтрокиДанных[0];
					Иначе
						СтрокаДанных = СтрокаВыборки;
					КонецЕсли;
					ОбработатьСоставнуюСтроку(ПараметрыЧека, ПоляСтрокиТаблицы, СтрокаШапкиЧека, ТаблицаДанных, СтрокаДанных, ИмяТаблицы);
				ИначеЕсли ПоляСтрокиТаблицы.ИмяКолонки = "Текст" Тогда
					Если ФискальныйРазделБыл Тогда
						Если НЕ ВыводитьНефискальныеПосле Тогда
							Продолжить;
						КонецЕсли;
					Иначе
						Если ИндексТекущейПозиции > 0 Тогда
							ПредыдущаяСтрока = ФискальныеПозицииЧека[ИндексТекущейПозиции - 1];
							Если ПредыдущаяСтрока.НомерСтрокиТовара = СтрокаВыборки.НомерСтрокиТовара Тогда
								Продолжить;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
					СтруктураПоиска = Новый Структура;
					СтруктураПоиска.Вставить("НомерСтрокиТовара", СтрокаВыборки.НомерСтрокиТовара);
					СтруктураПоиска.Вставить("ИмяТаблицы", "Товары");
					СтрокиДанных = ТаблицаДанных.НайтиСтроки(СтруктураПоиска);
					Если СтрокиДанных.Количество() > 0 Тогда
						СтрокаДанных = СтрокиДанных[0];
					Иначе
						СтрокаДанных = СтрокаВыборки;
					КонецЕсли;
					Если ПоляСтрокиТаблицы.ВыводитьКакШтрихкод Тогда
						ОбработатьДанныеШтрихкода(ПараметрыЧека, ПоляСтрокиТаблицы, СтрокаШапкиЧека, ТаблицаДанных, СтрокаДанных, ИмяТаблицы);
					Иначе
						ОбработатьТекстовуюСтроку(ПараметрыЧека, ПоляСтрокиТаблицы, СтрокаШапкиЧека, ТаблицаДанных, СтрокаДанных, ИмяТаблицы);
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			ПоследняяСтрока = СтрокаВыборки.НомерСтрокиТовара;
			ИндексТекущейПозиции = ИндексТекущейПозиции + 1;
		КонецЦикла;
	КонецЕсли;
КонецПроцедуры

Процедура ПроверитьТипШаблона(Объект, ИмяШаблона, ПроверяемыйТип, Отказ) Экспорт
	
	Шаблон = Объект[ИмяШаблона];
	Если ЗначениеЗаполнено(Шаблон) Тогда
		ТипШаблона = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Шаблон, "ТипШаблона");
		Если ТипШаблона <> ПроверяемыйТип Тогда
			ТекстСообщения = НСтр("ru = 'Выбранный шаблон не может использоваться для печати чека на указанном оборудовании.'")
							 + Символы.ПС + НСтр("ru = 'Тип шаблона ""%1"", а допустим только ""%2"".'");
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстСообщения, ТипШаблона, ПроверяемыйТип);
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
				ТекстСообщения,
				Объект,
				ИмяШаблона,
				"Объект",
				Отказ);
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область ВычислимыеПоля

// Получить пустую таблицу для хранения полей которые требуется вычислить.
//
Функция ПолучитьПустуюТаблицуВычисляемыхПолей()

	ТаблицаВычисляемыхПолей = Новый ТаблицаЗначений;
	ТаблицаВычисляемыхПолей.Колонки.Добавить("Поле",           Новый ОписаниеТипов("Строка"));
	ТаблицаВычисляемыхПолей.Колонки.Добавить("Значение");
	ТаблицаВычисляемыхПолей.Колонки.Добавить("НужноВычислять", Новый ОписаниеТипов("Булево"));
	ТаблицаВычисляемыхПолей.Колонки.Добавить("НомерПоля",      Новый ОписаниеТипов("Число"));
	ТаблицаВычисляемыхПолей.Колонки.Добавить("ЗаголовокПоля",  Новый ОписаниеТипов("Строка"));
	
	Возврат ТаблицаВычисляемыхПолей;

КонецФункции

// В таблице вычисляемых полей заполнить значения дополнительных полей.
//
Процедура ВТаблицеВычисляемыхПолейЗаполнитьДополнительные(ТаблицаВычисляемыхПолей)

	текДата = ТекущаяДатаСеанса();
	Для Каждого Стр Из ТаблицаВычисляемыхПолей Цикл
		Если ВРЕГ(Стр.Поле) = ВРЕГ("СистемныеПоля.ТекущаяДатаИВремя") Тогда
			Стр.Значение = Формат(текДата, "ДЛФ=DT");
			
		ИначеЕсли ВРЕГ(Стр.Поле) = ВРЕГ("СистемныеПоля.ТекущаяДата") Тогда
			Стр.Значение = Формат(текДата, "ДФ=dd.MM.yyyy");
			
		ИначеЕсли ВРЕГ(Стр.Поле) = ВРЕГ("СистемныеПоля.ТекущееВремя") Тогда
			Стр.Значение = Формат(текДата, "ДФ=ЧЧ:мм:сс");
			
		ИначеЕсли ВРЕГ(Стр.Поле) = ВРЕГ("СистемныеПоля.ИмяПользователя") Тогда
			Стр.Значение = ИмяПользователя();
			
		Иначе
			Стр.НужноВычислять = Истина;
			
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

// Добавить запись в таблицу вычисляемых полей.
//
Процедура ДобавитьПолеВТаблицуВычисляемыхПолей(ТаблицаВычисляемыхПолей, Поле, НужноВычислять)

	Если ТаблицаВычисляемыхПолей.Найти(Поле, "Поле") = Неопределено Тогда
		новСтр = ТаблицаВычисляемыхПолей.Добавить();
		новСтр.Поле = Поле;
		новСтр.НужноВычислять = НужноВычислять;
		новСтр.НомерПоля = 0;
	КонецЕсли;

КонецПроцедуры

// Из строки шаблона добавить все вычисляемые поля в таблицу.
//
Процедура ДобавитьПоляИзТекстаВТаблицуВычисляемыхПолей(ТаблицаВычисляемыхПолей, Текст)

	Для Сч = 1 По СтрЧислоСтрок(Текст) Цикл
		Стр = СтрПолучитьСтроку(Текст, Сч);
		
		Пока Истина Цикл
			Поз = Найти(Стр, "%%");
			Если Поз = 0 Тогда
				Прервать;
			КонецЕсли;
			Стр = Сред(Стр, Поз + 2);
			
			Поз = Найти(Стр, "%%");
			Если Поз = 0 Тогда
				Прервать;
			КонецЕсли;
			Поле = Лев(Стр, Поз-1);
			Стр = Сред(Стр, Поз+2);
			
			ДобавитьПолеВТаблицуВычисляемыхПолей(ТаблицаВычисляемыхПолей, Поле, Ложь);
		КонецЦикла;
		
	КонецЦикла;

КонецПроцедуры

// По тексту шаблона создать таблицу с вычисляемыми полями.
//
Функция ПолучитьВычисляемыеПоляИзТекста(Текст)

	ТаблицаВычисляемыхПолей = ПолучитьПустуюТаблицуВычисляемыхПолей();
	ДобавитьПоляИзТекстаВТаблицуВычисляемыхПолей(ТаблицаВычисляемыхПолей, Текст);
	ВТаблицеВычисляемыхПолейЗаполнитьДополнительные(ТаблицаВычисляемыхПолей);
	
	Возврат ТаблицаВычисляемыхПолей;

КонецФункции

#КонецОбласти

#Область РаботаССКД

// Для объекта получить макет СКД для подстановки в шаблоне.
//
Функция ПолучитьСхемуСКДДляПодстановкиВШаблоне(МетаданныеОбъекта, ИмяМакета = "")

	Имя = МетаданныеОбъекта.Имя;
	Если ПустаяСтрока(ИмяМакета) Тогда
		ИмяМакета = "ПоляШаблона";
	КонецЕсли;
	
	Если Метаданные.Справочники.Содержит(МетаданныеОбъекта) Тогда
		Возврат Справочники[Имя].ПолучитьМакет(ИмяМакета);
		
	ИначеЕсли Метаданные.Документы.Содержит(МетаданныеОбъекта) Тогда
		Возврат Документы[Имя].ПолучитьМакет(ИмяМакета);
		
	ИначеЕсли Метаданные.Отчеты.Содержит(МетаданныеОбъекта) Тогда
		Возврат Отчеты[Имя].ПолучитьМакет(ИмяМакета);
		
	ИначеЕсли Метаданные.Обработки.Содержит(МетаданныеОбъекта) Тогда
		Возврат Обработки[Имя].ПолучитьМакет(ИмяМакета);
		
	Иначе
		Возврат Неопределено;
		
	КонецЕсли;

КонецФункции

// В настройки СКД добавить отбор.
//
Функция ДобавитьОтборВНастройкиСКД(Настройки, Поле, Значение, ВидСравнения)

	ЭлементОтбора = Настройки.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ЭлементОтбора.Использование = Истина;
	ЭлементОтбора.ЛевоеЗначение = Поле;
	ЭлементОтбора.ПравоеЗначение = Значение;
	ЭлементОтбора.ВидСравнения = ВидСравнения;
	
	Возврат ЭлементОтбора;

КонецФункции

#КонецОбласти

#Область ЗаполнениеВИерархическихШаблонах

// Функция добавляет поле в выбранные поля настроек СКД.
//
// Параметры:
//  Компоновщик  - Компоновщик - Компоновщик
//  ИмяПоля      - Строка - Имя поля.
//  Заголовок    - Строка - Заголовок
//  Кэш          - Соответствие - Кэш полей.
//
Процедура ДобавитьВыбранноеПолеСКД(Компоновщик, ИмяПоля, Заголовок, Кэш)
	
	ПолеСКД = КомпоновкаДанныхСервер.НайтиПолеСКДПоПолномуИмени(Компоновщик.Настройки.Выбор.ДоступныеПоляВыбора.Элементы, ИмяПоля, Кэш);
	Если ПолеСКД <> Неопределено Тогда
		Поле = Компоновщик.Настройки.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
		Поле.Использование = Истина;
		Поле.Заголовок = Заголовок;
		Поле.Поле = ПолеСКД.Поле;
	Иначе
		
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область РаботаСМакетомТекстовогоДокумента

// Процедура вставляет в текстовый макет параметры области.
//
// Параметры:
//  Идентификатор      - <Строка> - Идентификатор области
//  Выравнивание       - <Строка> - Выравнивание в области: Лево, Право, ПоЦентру.
//  РазмещениеТекста   - <Число> - Размещение текста в области: Переносить, Обрезать или Забивать.
//  Формат             - <Строка> - Форматная строка области.
//  ТекстовыйДокумент  - <ТекстовыйДокумент> - Макет текстового документа.
//
Процедура ВставитьПараметрыОбласти(ТекстовыйДокумент, Идентификатор, Выравнивание = "Лево", РазмещениеТекста = 0, Формат = "")
	
	// Значения параметра "РазмещениеТекста":
	//  2 - Забивать
	//  1 - Обрезать
	//  0 - Переносить
	
	Если ЗначениеЗаполнено(Выравнивание)
		ИЛИ РазмещениеТекста = 2 
		ИЛИ ЗначениеЗаполнено(Формат) Тогда
		ТекстовыйДокумент.ДобавитьСтроку(Символы.Таб+"#Поле " +Идентификатор);
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Выравнивание) Тогда
		ТекстовыйДокумент.ДобавитьСтроку(Символы.Таб+Символы.Таб+"#Выравнивание "+Выравнивание);
	КонецЕсли;
	
	Если РазмещениеТекста = 2 Тогда
		ТекстовыйДокумент.ДобавитьСтроку(Символы.Таб+Символы.Таб+НСтр("ru = '#Забивать Истина'"));
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Формат) Тогда
		ТекстовыйДокумент.ДобавитьСтроку(Символы.Таб+Символы.Таб+"#Формат "+""""+Формат+"""");
	КонецЕсли;
	
КонецПроцедуры

// Процедура вставляет в текстовый макет блок начала области.
//
// Параметры:
//  Идентификатор      - <Строка> - Идентификатор области
//  ТекстовыйДокумент  - <ТекстовыйДокумент> - Макет текстового документа.
//
Процедура ВставитьНачалоОбласти(Идентификатор, ТекстовыйДокумент)
	ТекстовыйДокумент.ДобавитьСтроку("#Область "+Идентификатор);
	ТекстовыйДокумент.ДобавитьСтроку("#ЗаменаСимвола "+"""@"" ""#""");
КонецПроцедуры

// Процедура вставляет в текстовый макет блок окончания области.
//
// Параметры:
//  Идентификатор      - <Строка> - Идентификатор области
//  ТекстовыйДокумент  - <ТекстовыйДокумент> - Макет текстового документа.
//
Процедура ВставитьКонецОбласти(ТекстовыйДокумент)
	ТекстовыйДокумент.ДобавитьСтроку("#КонецОбласти");
КонецПроцедуры

// Процедура генерирует пустые строки необходимой ширины.
//
// Параметры:
//  Идентификатор      - <Строка> - Идентификатор области
//  ТекстовыйДокумент  - <ТекстовыйДокумент> - Макет текстового документа.
//
Функция ВставитьШиринуКолонки(Строка, Структура)
	
	Перем Ширина;
	Пробелы = "";
	
	Пробелы50 = "                                                  ";
	
	Значение = "";
	Структура.Свойство(Строка.Идентификатор,Значение);
	
	// Минимальная ширина колонки = 2 символам.
	
	// Ширина колонки не задана
	Если Строка.Ширина = 0 Тогда
		
		Ширина = СтрДлина(СокрЛП(Значение)) - 2;
		Если Ширина >= -1 Тогда
			
			МинимальноеКоличествоСтрок = Цел(Ширина/50);
			Для Счетчик = 0 По МинимальноеКоличествоСтрок Цикл
				Пробелы = Пробелы +Пробелы50;
			КонецЦикла;
			Пробелы = Лев(Пробелы, Ширина);
			
		КонецЕсли;
		
	// Колонка имеет фиксированную ширину.
	Иначе
		
		Ширина = Строка.Ширина - 2;
		Если Строка.Ширина > 2 Тогда
			
			МинимальноеКоличествоСтрок = Цел(Ширина/50);
			Для Счетчик = 0 По МинимальноеКоличествоСтрок Цикл
				Пробелы = Пробелы +Пробелы50;
			КонецЦикла;
			Пробелы = Лев(Пробелы, Ширина);
			
		КонецЕсли;
		
		// Обрежем строку если для строки стоит флаг Обрезать.
		Если Строка.РазмещениеТекста = 1 Тогда
			Структура.Вставить(Строка.Идентификатор, Лев(Значение,Строка.Ширина));
		КонецЕсли;
	КонецЕсли;
	
	//Структура.Пробелы.Вставить(Ширина, Пробелы);
	
	Возврат Пробелы;
	
КонецФункции

// Процедура вставляет в текстовый макет блок области.
//
// Параметры:
//  Область      - <Строка> - Идентификатор области
//  ТекстовыйДокумент  - <ТекстовыйДокумент> - Макет текстового документа.
//  Структура  - <Структура> - Структура параметров
//
Процедура ВставитьТелоСтрокиОбласти(СтрокаОбласти, ТекстовыйДокумент, Структура)
	
	Если СтрокаОбласти.ТипЭлемента = "СтрокаТекста"
		ИЛИ СтрокаОбласти.ТипЭлемента = "СтрокаДанных"
		ИЛИ СтрокаОбласти.ТипЭлемента = "СоставнаяСтрока" Тогда
		
		// Пустой результат строки не выводится.
		Значение = "";
		Структура.Свойство(СтрокаОбласти.Идентификатор,Значение);
		
		ВставитьПараметрыОбласти(ТекстовыйДокумент, СтрокаОбласти.Идентификатор, СтрокаОбласти.Выравнивание, СтрокаОбласти.РазмещениеТекста, СтрокаОбласти.Формат);
		
		ТекстовыйДокумент.ДобавитьСтроку("[" + ВставитьШиринуКолонки(СтрокаОбласти, Структура) + "]" + "#Поля " + СтрокаОбласти.Идентификатор);
		Если СтрокаОбласти.РазмещениеТекста = 0 Тогда
			ТекстовыйДокумент.ДобавитьСтроку("<" + ВставитьШиринуКолонки(СтрокаОбласти, Структура) + ">" + "#Поля " + СтрокаОбласти.Идентификатор);
		КонецЕсли;
		
	ИначеЕсли СтрокаОбласти.ТипЭлемента = "Таблица" Тогда
		
		// Пустая таблица не выводится.
		Если СтрокаОбласти.Строки.Количество() = 0 Тогда
			Возврат;
		КонецЕсли; 
		
		Для каждого Колонка Из СтрокаОбласти.Строки Цикл
			ВставитьПараметрыОбласти(ТекстовыйДокумент, Колонка.Идентификатор, Колонка.Выравнивание, Колонка.РазмещениеТекста, Колонка.Формат);
		КонецЦикла;
		
		// Формирование колонок
		ДобавляемаяСтрока = "";
		Идентификаторы    = "";
		СтрокаПереноса    = "";
		ИдентификаторыСтрокПереноса = "";
		
		ПустаяСтрока = Истина;
		Для каждого Колонка Из СтрокаОбласти.Строки Цикл
			
			// Пустые строки таблицы не выводятся.
			Если ПустаяСтрока Тогда
				Значение = Неопределено;
				Структура.Свойство(Колонка.Идентификатор,Значение);
				Если Значение <> Неопределено И ЗначениеЗаполнено(Значение) Тогда
					ПустаяСтрока = Ложь;
				КонецЕсли;
			КонецЕсли;
			
			ШиринаКолонки = ВставитьШиринуКолонки(Колонка, Структура);
			
			ДобавляемаяСтрока = ДобавляемаяСтрока + "[" + ШиринаКолонки + "]";
			Идентификаторы = Идентификаторы + " " + Колонка.Идентификатор;
			
			Если Колонка.РазмещениеТекста = 0 Тогда
				СтрокаПереноса = СтрокаПереноса + "<" + ШиринаКолонки + ">";
				ИдентификаторыСтрокПереноса = ИдентификаторыСтрокПереноса + " " + Колонка.Идентификатор;
			Иначе
				СтрокаПереноса = СтрокаПереноса + " " + ШиринаКолонки + " ";
			КонецЕсли;
			
		КонецЦикла;
		
		// Пустые строки таблицы не выводятся.
		Если ПустаяСтрока Тогда
			 Возврат;
		КонецЕсли;
		
		ТекстовыйДокумент.ДобавитьСтроку(ДобавляемаяСтрока + "#Поля "+ Идентификаторы);
		Если Найти(СтрокаПереноса, "<")>0 Тогда
			ТекстовыйДокумент.ДобавитьСтроку(СтрокаПереноса + "#Поля "+ ИдентификаторыСтрокПереноса);
		КонецЕсли;
		
	КонецЕсли;
		
КонецПроцедуры

// Процедура вставляет в текстовый макет блок области.
//
// Параметры:
//  Область      - <Строка> - Идентификатор области
//  ТекстовыйДокумент  - <ТекстовыйДокумент> - Макет текстового документа.
//  Структура  - <Структура> - Структура параметров
//
Процедура ВставитьТелоОбласти(Область, ТекстовыйДокумент, Структура)
	
	Для каждого СтрокаОбласти Из Область.Строки Цикл
		
		ВставитьТелоСтрокиОбласти(СтрокаОбласти, ТекстовыйДокумент, Структура);

	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область РаботаСПараметрамиИерархическогоШаблона

// Функция заполняет структуру параметров, которые необходимо получить в СКД.
// Рекурсивная функция.
//
// Параметры:
//  Шаблон  - <ДеревоЗначений> - Шаблон. В строках шаблона могут находиться параметры.
//  Структура  - <Структура> - Структура, которую необходимо заполнить параметрами.
//
// Возвращаемое значение:
//   Структура   - структура параметров, которые необходимо получить
//                   в системе компоновки данных.
//
Функция ПолучитьИдентификаторыПолейСКД(Шаблон, Структура = Неопределено)
	
	Если Структура = Неопределено Тогда
		Структура = Новый Структура;
	КонецЕсли;
	
	Для каждого Строка Из Шаблон.Строки Цикл
		
		Если Строка.ТипЭлемента = "СтрокаТекста" И Строка.Вычислять Тогда
			ВычисляемыеПоля = ПолучитьВычисляемыеПоляИзТекста(Строка.Элемент);
			Если ВычисляемыеПоля.Количество() > 0 Тогда
				Для каждого СтрокаТЗ Из ВычисляемыеПоля Цикл
					Структура.Вставить(ПолучитьИдентификатор(),СтрокаТЗ.Поле);
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
		
		Если НЕ Строка.ТипЭлемента = "СтрокаДанных" Тогда
			ПолучитьИдентификаторыПолейСКД(Строка, Структура);
		Иначе
			Структура.Вставить(Строка.Идентификатор,СтрЗаменить(Строка.Элемент,"%%",""));
		КонецЕсли;
		
	КонецЦикла;

	Возврат Структура;
	
КонецФункции

#КонецОбласти

#Область РаботаСИерархическимШаблоном

// Функция получает макет текстового документа для строки дерева (шаблона).
//
// Параметры:
//  <СтрокаДерева>  - <СтрокаДереваЗначений> - строка шаблона
//  <Структура>  - <Структура> - параметры, которые необходимо 
//                 подставить в макет шаблона.
//
// Возвращаемое значение:
//   <ТекстовыйДокумент>   - Макет текстового документа для строки дерева,
//
Функция ПолучитьМакетДляСтрокиДерева(СтрокаДерева, Структура)
	
	// Кэширование СтрокДерева
	
	ТекстовыйДокумент = Новый ТекстовыйДокумент;
	
	ВставитьНачалоОбласти(СтрокаДерева.Идентификатор, ТекстовыйДокумент);
	
	Если СтрокаДерева.Уровень() = 0 Тогда
		ВставитьТелоОбласти(СтрокаДерева, ТекстовыйДокумент, Структура);
	Иначе
		ВставитьТелоСтрокиОбласти(СтрокаДерева, ТекстовыйДокумент, Структура);
	КонецЕсли;
	
	ВставитьКонецОбласти(ТекстовыйДокумент);
	
	Возврат ТекстовыйДокумент;
	
КонецФункции // ПолучитьМакетДляВетвиДерева()

// Функция выполняет преобразование шаблона (строки дерева) в текстовый документ, заполненный по структуре параметров.
//
// Параметры:
//  <СтрокаДерева>  - <СтрокаДереваЗначений> - строка шаблона
//  <СтруктураПараметров>  - <Структура> - параметры, которые необходимо 
//                 подставить в макет шаблона.
//
// Возвращаемое значение:
//   <ТекстовыйДокумент>   - результирующий текстовый документ,
//   полученный по макету для строки дерева.
//
Функция ПолучитьТекстовыйДокументДляСтрокиДереваШаблона(СтрокаДерева, СтруктураПараметров)

	Если СтрокаДерева = Неопределено Тогда
		Возврат Новый ТекстовыйДокумент;
	КонецЕсли;
	ОбластьМакета = СтруктураПараметров.КэшМакетов.Получить(СтрокаДерева.Идентификатор);
	
	// Заполним макет
	Если ОбластьМакета = Неопределено Тогда
		Макет = ПолучитьМакетДляСтрокиДерева(СтрокаДерева, СтруктураПараметров);
		ОбластьМакета = Макет.ПолучитьОбласть(СтрокаДерева.Идентификатор);
		Если НЕ ЗначениеЗаполнено(СтрокаДерева.ПустоеЗначение) Тогда
			СтруктураПараметров.КэшМакетов.Вставить(СтрокаДерева.Идентификатор, ОбластьМакета);
		КонецЕсли;
	Иначе
		// Получен макет из кэша
	КонецЕсли;
	
	ОбластьМакета.Параметры.Заполнить(СтруктураПараметров);
	
	// Выведем результат в массив строк.
	ТекстовыйДокумент = Новый ТекстовыйДокумент;
	ТекстовыйДокумент.Вывести(ОбластьМакета);

	Возврат ТекстовыйДокумент;
	
КонецФункции

// Функция выполняет преобразование текстового документа в массив строк.
//
// Параметры:
//  <ТекстовыйДокумент>  - Текстовый документ, который необходимо
//                 преобразовать в массив строк.
//
// Возвращаемое значение:
//   <Массив>   - Массив текстовых строк.
//
Функция ПреобразоватьТекстовыйДокументВМассивСтрок(ТекстовыйДокумент)
	
	МассивТекстовыхСтрок = Новый Массив;
	
	Для Счетчик = 1 По ТекстовыйДокумент.КоличествоСтрок() Цикл
		ЗначениеСтроки = ТекстовыйДокумент.ПолучитьСтроку(Счетчик);
		Если ЗначениеЗаполнено(ЗначениеСтроки) Тогда
			МассивТекстовыхСтрок.Добавить(ЗначениеСтроки);
		КонецЕсли;
	КонецЦикла;
	
	Возврат МассивТекстовыхСтрок;
	
КонецФункции

Процедура ОбработатьТекстовуюСтроку(ПараметрыЧека, ПоляСтроки, СтрокаШапкиЧека, ТаблицаДанных, СтрокаДанных = Неопределено, ИмяРаздела = "СоставЧека")
	
	ЗначениеСтроки = УправлениеШаблонами.ЗначениеТекстовогоПоля(ПараметрыЧека.ДокументОснование, ПоляСтроки, СтрокаШапкиЧека, ТаблицаДанных, СтрокаДанных, ИмяРаздела);
	Если ЗначениеЗаполнено(ЗначениеСтроки)
		ИЛИ ПоляСтроки.ВыводитьПустоеЗначение Тогда
		ТекстСтроки = ПоляСтроки.Префикс
					+ Формат(ЗначениеСтроки, ПоляСтроки.Формат)
					+ ПоляСтроки.Постфикс;
		СтрокаПозицииЧека = Новый Структура;
		СтрокаПозицииЧека.Вставить("ТекстоваяСтрока");
		СтрокаПозицииЧека.Вставить("Текст", ТекстСтроки);
		Если ПоляСтроки.Выравнивание = "Право" Тогда
			СтрокаПозицииЧека.Вставить("Выравнивание", "Право");
		ИначеЕсли ПоляСтроки.Выравнивание = "Центр" Тогда
			СтрокаПозицииЧека.Вставить("Выравнивание", "Центр");
		КонецЕсли;
		Если ПоляСтроки.РазмещениеТекста = 0 Тогда
			СтрокаПозицииЧека.Вставить("ПереносСтроки", Истина);
		КонецЕсли;
		ПараметрыЧека.ПозицииЧека.Добавить(СтрокаПозицииЧека);
	КонецЕсли;
	
КонецПроцедуры

Процедура ОбработатьДанныеШтрихкода(ПараметрыЧека, ПоляСтроки, СтрокаШапкиЧека, ТаблицаДанных, СтрокаДанных = Неопределено, ИмяРаздела = "СоставЧека")
	
	ЗначениеСтроки = УправлениеШаблонами.ЗначениеТекстовогоПоля(ПараметрыЧека.ДокументОснование, ПоляСтроки, СтрокаШапкиЧека, ТаблицаДанных, СтрокаДанных, ИмяРаздела);
	Если ЗначениеЗаполнено(ЗначениеСтроки)
		ИЛИ ПоляСтроки.ВыводитьПустоеЗначение Тогда
		Попытка
			ТипШтрихкодаРТ = ПоляСтроки.ТипШтрихкода;
		Исключение
			СтрокаОшибки = НСтр("ru = 'Не удалось определить тип штрихкода. Следует отредактировать шаблон чека.'") + Символы.ПС + ОписаниеОшибки();
			ТипШтрихкодаРТ = 99;
		КонецПопытки;
		Если ТипШтрихкодаРТ = 99 Тогда
			ТипШтрихкодаРТ = МенеджерОборудованияВызовСервера.ОпределитьТипШтрихкода(ЗначениеСтроки);
		Иначе
			Если ТипШтрихкодаРТ = 0 Тогда
				ТипШтрихкодаРТ = "EAN8";
			ИначеЕсли ТипШтрихкодаРТ = 1 Тогда
				ТипШтрихкодаРТ = "EAN13";
			ИначеЕсли ТипШтрихкодаРТ = 2 Тогда
				ТипШтрихкодаРТ = "EAN128";
			ИначеЕсли ТипШтрихкодаРТ = 3 Тогда
				ТипШтрихкодаРТ = "CODE39";
			ИначеЕсли ТипШтрихкодаРТ = 4 Тогда
				ТипШтрихкодаРТ = "CODE128";
			ИначеЕсли ТипШтрихкодаРТ = 11 Тогда
				ТипШтрихкодаРТ = "ITF14";
			ИначеЕсли ТипШтрихкодаРТ = 16 Тогда
				ТипШтрихкодаРТ = "QR";
			ИначеЕсли ТипШтрихкодаРТ = 14 Тогда
				ТипШтрихкодаРТ = "EAN13Addon2";
			ИначеЕсли ТипШтрихкодаРТ = 15 Тогда
				ТипШтрихкодаРТ = "EAN13Addon5";
			КонецЕсли;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(ПоляСтроки.Префикс) Тогда
			СтрокаПозицииЧека = Новый Структура;
			СтрокаПозицииЧека.Вставить("ТекстоваяСтрока");
			СтрокаПозицииЧека.Вставить("Текст", ПоляСтроки.Префикс);
			ПараметрыЧека.ПозицииЧека.Добавить(СтрокаПозицииЧека);
		КонецЕсли;
	
		СтрокаПозицииЧека = Новый Структура;
		СтрокаПозицииЧека.Вставить("ШтрихКод", ЗначениеСтроки);
		СтрокаПозицииЧека.Вставить("ТипШтрихкода", ТипШтрихкодаРТ);
		ПараметрыЧека.ПозицииЧека.Добавить(СтрокаПозицииЧека);
		
		Если ЗначениеЗаполнено(ПоляСтроки.ПостФикс) Тогда
			СтрокаПозицииЧека = Новый Структура;
			СтрокаПозицииЧека.Вставить("ТекстоваяСтрока");
			СтрокаПозицииЧека.Вставить("Текст", ПоляСтроки.ПостФикс);
			ПараметрыЧека.ПозицииЧека.Добавить(СтрокаПозицииЧека);
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ОбработатьСоставнуюСтроку(ПараметрыЧека, ПоляСтроки, СтрокаШапкиЧека, ТаблицаДанных, СтрокаДанных = Неопределено, ИмяРаздела = "СоставЧека")
	
	ТекстСтроки = "";
	Для Каждого ПараметрСтроки Из ПоляСтроки.Строки Цикл
		Если ЗначениеЗаполнено(ПараметрСтроки.ИмяКолонки) Тогда
			ЗначениеПоля = УправлениеШаблонами.ЗначениеТекстовогоПоля(ПараметрыЧека.ДокументОснование, ПараметрСтроки, СтрокаШапкиЧека, ТаблицаДанных, СтрокаДанных, ИмяРаздела);;
			
			Если ЗначениеЗаполнено(ЗначениеПоля) Тогда
			
				ДлинаПостфикса = СтрДлина(ПараметрСтроки.Постфикс);
				ПозицияСимволаПереноса = СтрНайти(ПараметрСтроки.Постфикс, Символ(182));
				ЕстьПереносСтроки = ПозицияСимволаПереноса > 0;
				
				ТекстСтроки = ТекстСтроки
								+ ПараметрСтроки.Префикс
								+ Формат(ЗначениеПоля, ПараметрСтроки.Формат)
								+ ?(ЕстьПереносСтроки, Лев(ПараметрСтроки.Постфикс, ПозицияСимволаПереноса - 1), ПараметрСтроки.Постфикс);
				Если ЕстьПереносСтроки Тогда
					Если ЗначениеЗаполнено(ТекстСтроки)
						ИЛИ ПоляСтроки.ВыводитьПустоеЗначение Тогда
						СтрокаПозицииЧека = Новый Структура;
						СтрокаПозицииЧека.Вставить("ТекстоваяСтрока");
						СтрокаПозицииЧека.Вставить("Текст", ТекстСтроки);
						ПараметрыЧека.ПозицииЧека.Добавить(СтрокаПозицииЧека);
					КонецЕсли;
					ТекстСтроки = Прав(ПараметрСтроки.Постфикс, ДлинаПостфикса - ПозицияСимволаПереноса);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Если ЗначениеЗаполнено(ТекстСтроки) Тогда
		СтрокаПозицииЧека = Новый Структура;
		СтрокаПозицииЧека.Вставить("ТекстоваяСтрока");
		СтрокаПозицииЧека.Вставить("Текст", ТекстСтроки);
		Если ПоляСтроки.Выравнивание = "Право" Тогда
			СтрокаПозицииЧека.Вставить("Выравнивание", "Право");
		ИначеЕсли ПоляСтроки.Выравнивание = "Центр" Тогда
			СтрокаПозицииЧека.Вставить("Выравнивание", "Центр");
		КонецЕсли;
		Если ПоляСтроки.РазмещениеТекста = 0 Тогда
			СтрокаПозицииЧека.Вставить("ПереносСтроки", Истина);
		КонецЕсли;
		ПараметрыЧека.ПозицииЧека.Добавить(СтрокаПозицииЧека);
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#КонецОбласти